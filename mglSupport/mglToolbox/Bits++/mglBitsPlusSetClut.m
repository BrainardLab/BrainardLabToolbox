function mglBitsPlusSetClut(clutOrTexturePtr, rect, doFlip, doEncode)
%  mglBitsPlusSetClut(clutOrTexturePtr, [rect], [doFlip], [doEncode])
%
% 'clutOrTexturePtr' will either be a 256x3 matrix in the range [0,1]
% or it will be a texture generated by mglBitsPlusPlusClut2Texture.
%
% 'rect' lets you define the rect that specifies where the magic code is
% written.  For a typical application, this should be left empty.  However,
% for programs that modify the projection matrix via MOGL, you will want to
% change this to draw the magic code in a more cosmetically appealing
% location.
%
% If 'doFlip' is set to 1, then BitsPlusSetClut will call flip at the
% end of the function.  By default, this value is 1.
%
% If 'doEncode' is set to false, the function assumes that the clut being
% passed has already been encoded.  This can save time if you aren't
% adjusting the clut every frame.  By default, this is true.

global GL MGL;

if isempty(GL)
	InitializeMatlabOpenGL;
end

if nargin < 1 || nargin > 4
    error('Usage: BitsPlusSetClut(clutOrTexturePtr, [rect], [doFlip], [doEncode])');
end

switch nargin
    case 1
        rect = [];
        doFlip = true;
		doEncode = true;
    case 2
        doFlip = true;
		doEncode = true;
	case 3
		doEncode = true;
end

% Make sure that 'rect' has valid dimensions.
if ~isempty(rect) && (size(rect, 1) ~= 1 || size(rect, 2) ~= 4)
    error('rect must be a 4 element vector.');
end

% Decide if we've been passed a texture pointer or a clut matrix.
isTexture = isstruct(clutOrTexturePtr);

if ~isTexture
	if doEncode
		% Convert the clut into Bits++ values.
		clutOrTexturePtr = clutOrTexturePtr .* (2^16 - 1);

		% Encode the LUT.
		newClutRow = BitsPlusEncodeClutRow(clutOrTexturePtr) ./ 255;
	else
		newClutRow = clutOrTexturePtr;
	end
end

% check that the screen width is at least 524 pixels
if MGL.screenWidth < 524
	error('Window is not big enough to encode the Bits++ CLUT.');
end

if isempty(rect)
	if isTexture
		rect = [clutOrTexturePtr.imageWidth/2+1, 1];
	else
		rect = [0, 0, size(newClutRow, 2), 1];
	end
end

if isTexture
	mglBltTexture(clutOrTexturePtr, rect);
else
	mglDrawImage(newClutRow, [size(newClutRow, 2)/2 0]);
end

if doFlip
	mglFlush;
end

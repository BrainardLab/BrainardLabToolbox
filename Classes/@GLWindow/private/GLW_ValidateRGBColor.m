function validatedRGBColor = GLW_ValidateRGBColor(desiredRGBColor, displayTypeID)
% GLW_ValidateRGBColor - Validates an RGB value.
%
% Syntax:
% validatedRGBColor = GLW_ValidateRGBColor(desiredRGBColor, displayTypeID)
%
% Description:
% Validates an RGB value according to the display type.
%
% Input:
% desiredRGBColor (Mx3|struct|cell array) - The RGB color to be validated.
% displayTypeID (integer) - The display ID type of the GLWindow.
%     This value should be generated by GLW_ValidateDisplayType.
%
% Output:
% desiredRGBColor (Mx3) - The validated RGB color.

switch displayTypeID
	case {GLWindow.DisplayTypes.Normal, GLWindow.DisplayTypes.BitsPP}
		if ndims(desiredRGBColor) ~= 2 || ~all(size(desiredRGBColor) == [1 3])
			error('desiredRGBColor must be a 1x3 array.');
		end
		
	case {GLWindow.DisplayTypes.Stereo, GLWindow.DisplayTypes.StereoBitsPP}
		if isstruct(desiredRGBColor)
			% Validate the fields in the desiredWindowID struct.
			GLW_ValidateStructFields(desiredRGBColor, {'left', 'right'});
			
			% Make sure both fields are 1x3 vectors.
			checkRGBDims(desiredRGBColor.left);
			checkRGBDims(desiredRGBColor.right);
			
			desiredRGBColor = [desiredRGBColor.left ; desiredRGBColor.right];
		elseif ndims(desiredRGBColor) == 2 && all(size(desiredRGBColor) == [2 3])
			% Do nothing here because they desiredRGBColor is in the right
			% format.
		else
			error('desiredRGBColor must be a 2x3 matrix or a struct.');
		end
		
	case GLWindow.DisplayTypes.HDR
		if isstruct(desiredRGBColor)
			% Validate the fields in the desiredWindowID struct.
			GLW_ValidateStructFields(desiredRGBColor, {'front', 'back'});
			
			desiredRGBColor = [desiredRGBColor.front ; desiredRGBColor.back];
		elseif ndims(desiredRGBColor) == 2 && all(size(desiredRGBColor) == [2 3])
			% Do nothing here because they desiredRGBColor is in the right
			% format.
		elseif iscell(desiredRGBColor) && length(desiredRGBColor) == 2
			% Check that the RGB colors are 1x3 arrays.
			for i = 1:length(desiredRGBColor)
				if ~all(size(desiredRGBColor{i}) == [1 3])
					error('Each element of the RGB cell array must be a 1x3.');
				end
			end
			
			desiredRGBColor = [desiredRGBColor{1} ; desiredRGBColor{2}];
		else
			error('desiredRGBColor must be a 2x3 matrix or a struct.');
		end
	
	case GLWindow.DisplayTypes.StereoHDR
		% The number of colors we expect to be passed.
		numColors = length(GLWindow.DisplayFields.StereoHDR);
		
		if isstruct(desiredRGBColor)
			% Make sure we have the right fields.
			GLWValidateStructFields(desiredRGBColor, GLWindow.DisplayFields.StereoHDR);
			
			% Pack the colors into a matrix.
			c = zeros(numColors, 3);
			for i = 1:length(GLWindow.DisplayFields.StereoHDR)
				c(i,:) = desiredRGBColor.(GLWindow.DisplayFields.StereoHDR{i});
			end
			desiredRGBColor = c;
		elseif iscell(desiredRGBColor)
			% Make sure the cell array is a vector of the right length.
			assert(isvector(desiredRGBColor) && length(desiredRGBColor) == numColors, ...
				'GLW_ValidateRGBColor:InvalidDims', ...
				'RGB color defined as a cell array must have %d elements.', ...
				numColors);
		
			% Pack the colors into a matrix.
			c = zeros(numColors, 3);
			for i = 1:length(GLWindow.DisplayFields.StereoHDR)
				c(i,:) = desiredRGBColor.(GLWindow.DisplayFields.StereoHDR{i});
			end
			desiredRGBColor = c;
		elseif isequal(size(desiredRGBColor), [numColors 3])
			% Do nothing the colors are in the right format.
		else
			error('In StereoHDR mode, RGB values must be specified as a struct, %d element cell array, or a %dx3 matrix.', ...
				numColors, numColors);
		end
		
	otherwise
		error('Invalid display type ID %d.\n', displayTypeID);
end

% Check to make sure all values are in the [0,1] range.
if any(desiredRGBColor(:) < 0) || any(desiredRGBColor(:) > 1)
	error('All RGB values must be in the [0,1] range.');
end

validatedRGBColor = desiredRGBColor;


function checkRGBDims(rgbVal)
if ndims(rgbVal) ~= 2 || ~all(size(rgbVal) == [1 3])
	error('desiredRGBColor must be a 1x3 array or contain 1x3 arrays.');
end

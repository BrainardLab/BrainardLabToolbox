function validatedWindowID = GLW_ValidateWindowID(desiredWindowID, displayTypeID, fullScreen)
% validatedWindowID = GLW_ValidateWindowID(desiredWindowID, displayTypeID)
%
% Description:
% Validates the desired window ID based on the display type ID.  A desired
% window ID of NaN implies default values.  Usually, you will ask for the
% defaults.
%
% Input:
% desiredWindowID (integer|struct|[]) - The desired window ID(s).  Passing
%   value of NaN tells the function to figure out some reasonable defaults
%   based on the display type.
% displayTypeID (integer) - The display ID type of the GLWindow.
%   This value should be generated by GLW_ValidateDisplayType.
% fullScreen (logical) - Indicates if GLWindow is in fullscreen mode.
%
% Output:
% validatedWindowID (array) - The validated window ID(s).

switch displayTypeID
	% Normal and Bits++
	case {GLWindow.DisplayTypes.Normal, GLWindow.DisplayTypes.BitsPP}
		if isempty(desiredWindowID) % Default.
			validatedWindowID = -1;
		elseif isscalar(desiredWindowID)
			validatedWindowID = desiredWindowID;
		else
			error('For display types "normal" and "bits++", the window ID must be an integer value or NaN.');
		end
	
	% Stereo and Stereo Bits++
	case {GLWindow.DisplayTypes.Stereo, GLWindow.DisplayTypes.StereoBitsPP}
		if isempty(desiredWindowID) % Default.
			validatedWindowID = [3 2]; %[left right]
		elseif isstruct(desiredWindowID)
			% Validate the fields in the desiredWindowID struct.
			GLW_ValidateStructFields(desiredWindowID, {'left', 'right'});
			
			% Check to see if the window IDs are in the normal range.
			if desiredWindowID.left < 1 || desiredWindowID.right < 1
				error('Windows IDs for "sterobits++" displays must be >= 1.');
			end
			
			% Make sure the display IDS aren't the same.
			if desiredWindowID.left == desiredWindowID.right
				error('Window IDs cannot be the same.');
			end
			
			validatedWindowID = [desiredWindowID.left, desiredWindowID.right];
		else
			error('For display type "stereobits++", the window ID must be a struct.');
		end
		
	% HDR
	case GLWindow.DisplayTypes.HDR
		if isempty(desiredWindowID) % Default
			% In fullscreen mode we try to find the proper monitor IDs.  In
			% non fullscreen mode we don't care and set them to arbitrary
			% values.
			if fullScreen
				[fid, bid] = HDRGetMonitorIDs;
				validatedWindowID = [fid, bid];
			else
				validatedWindowID = [3 4];
			end
		else
			% Due to how funky our HDR display IDs are, we won't let people
			% explicitly set them for fear of screwing things up.
			error('Window IDs cannot be explicitly set for HDR displays.');
		end
	
	% Stereo HDR
	case GLWindow.DisplayTypes.StereoHDR
		% In Stereo HDR mode, we never want the user to specify the monitor
		% IDs because they are very specific.  There is a program called
		% SHDRFindMonitorIDs that does this for the user.
		assert(isempty(desiredWindowID), 'GLW_ValidateWindowID:InvalidWindowID', ...
			'In Stereo HDR mode, the user cannot manually specify window IDs.');
		
		if fullScreen
			% This program gets the stored monitor IDs.  These should
			% always remain the same unless a configuration changes, in
			% which case this function will throw an error letting the user
			% know.
			[leftIDs, rightIDs] = SHDRGetMonitorIDs;
			
			% Stick the window IDs in a vector.  The order of the vector
			% follows the order of the fields found in the class constant
			% GLWindow.DisplayFields.StereoHDR.  Ideally, the order would
			% be dynamically determined from that constant instead of hard
			% coding it like I am and shouldn't be.
			validatedWindowID = [leftIDs.front, leftIDs.back, ...
								 rightIDs.front, rightIDs.back];
		else
			% In non fullscreen mode these numbers don't really matter.
			validatedWindowID = 1:4;
		end
	
	% Any undefined display types.
	otherwise
		error('Invalid display type ID of "%d".', displayTypeID);
end

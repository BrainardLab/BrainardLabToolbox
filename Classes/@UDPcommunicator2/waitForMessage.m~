function message = waitForMessage(obj, msgLabel, varargin)
    
    p = inputParser;
    addRequired(p,'msgLabel');
    addOptional(p,'timeOutSecs', Inf,@isnumeric);
    parse(p,msgLabel,varargin{:});
    timeOutSecs = p.Results.timeOutSecs;
    expectedMessageLabel = p.Results.msgLabel;
    if isempty(expectedMessageLabel)
        expectedMessageLabel = '';
    end
    if (~ischar(expectedMessageLabel))
        error('%s The expected message label must be a string, or an empty array, i.e.: []\n',obj.waitForMessageSignature);
    end
    
    % initialize response struct
    message = struct(...
        'label', '', ...            % a string
        'data', [], ...             % either empty or a struct
        'timedOutFlag', false ...   % a flag indicating whether we timeout - is this needed?
    );

    % Wait until we get something
    fprintf('%s: Waiting for something to arrive ...', obj.waitForMessageSignature);
    tic;
    while (~matlabUDP('check'))
        elapsedTime = toc;
        if (elapsedTime > timeOutSecs)
            response.timedOutFlag = true;
        end
    end
    
    if (response.timedOutFlag == false)
        % Read message label: 1 string, no spaces
        message.label = matlabUDP('receive');
        
        % Read number of bytes of ensuing data
        bytesString = matlabUDP('receive');
        numBytes = str2double(bytesString);
        
        % Read the data bytes
        fprintf('Will read %d char\n', numBytes);
        % Read all bytes
        theData = [];
        for k = 1:numBytes
            waitForNewDataArrival();
            theData(k) = str2double(matlabUDP('receive'));
        end
        
        % Read the message label again
        waitForNewDataArrival();
        if (~strcmp(message.label,matlabUDP('receive')))
            error('Training message label does not match leading message label');
        end
        
        % Reconstruct data object
        message.data = getArrayFromByteStream(uint8(theData));
    end
  
    % Wait to receive a message
    if (~strcmp(obj.verbosity,'min')) && (~strcmp(obj.verbosity,'none'))
        % give some feedback
        if isinf(timeOutSecs)
            fprintf('%s  Waiting for ever to receive a ''%s'' message .... ', obj.waitForMessageSignature, expectedMessageLabel);
        else
            fprintf('%s  Waiting for %2.2f milli-seconds to receive a ''%s'' message ... ', obj.waitForMessageSignature, timeOutSecs*1000, expectedMessageLabel);
        end
    end
    
    
    
    while ((data==0) && (message.timedOutFlag == false))
        data = matlabUDP('check');
        elapsedTime = toc;
        if (elapsedTime > timeOutSecs)
            response.timedOutFlag = true;
        end
    end % while
    
    if (response.timedOutFlag == false)
        % get raw data
        rawMessage = receiveAndUpdateCounter(obj);
        
        % parse the raw message received
        leftBracketPositions = strfind(rawMessage, sprintf('['));
        rightBracketPositions = strfind(rawMessage, sprintf(']'));
        if ((numel(leftBracketPositions) ~= 3) || (numel(rightBracketPositions) ~= 3))
            error('%s Raw message received (%s) does not contain correct format. Incorrect number of brackets\n', obj.waitForMessageSignature, rawMessage);
        end
        
        response.msgLabel = rawMessage(leftBracketPositions(1)+1:rightBracketPositions(1)-1);
        response.msgValueType = rawMessage(leftBracketPositions(2)+1:rightBracketPositions(2)-1);
        if (strcmp(lower(response.msgValueType), 'numeric'))
            response.msgValue = str2double(rawMessage(leftBracketPositions(3)+1:rightBracketPositions(3)-1));
        elseif (strcmp(lower(response.msgValueType), 'boolean'))
            response.msgValue = str2double(rawMessage(leftBracketPositions(3)+1:rightBracketPositions(3)-1));
            if (response.msgValue == 0)
                response.msgValue = false;
            else
                response.msgValue = true;
            end
        elseif (strcmp(lower(response.msgValueType), 'string'))
            response.msgValue = rawMessage(leftBracketPositions(3)+1:rightBracketPositions(3)-1);
        else
            error('Do not know how to handle message value type: ''%s''\n', response.msgValueType); 
        end
        
        response.msgLabel
        obj.ABORT_MESSAGE.label
        
        % check if the message label we received is the same as the one we are expecting, and inform the sender
        if (strcmp(response.msgLabel, expectedMessageLabel))    
            % Do not send back an TRANSMITTED_MESSAGE_MATCHES_EXPECTED message 
            % when we were expecting a TRANSMITTED_MESSAGE_MATCHES_EXPECTED and we received it
            if (strcmp(expectedMessageLabel, obj.TRANSMITTED_MESSAGE_MATCHES_EXPECTED))
                if (strcmp(obj.verbosity,'max'))
                    fprintf('%s Received expected message (''%s'')\n', obj.waitForMessageSignature,  expectedMessageLabel);
                end
            else 
                % Send back a TRANSMITTED_MESSAGE_MATCHES_EXPECTED message 
                obj.sendMessage(obj.TRANSMITTED_MESSAGE_MATCHES_EXPECTED, 'nan', 'doNotreplyToThisMessage', true);
                if (~strcmp(obj.verbosity,'min'))  && (~strcmp(obj.verbosity,'none'))
                    fprintf('%s Expected message received within %2.2f milli-seconds, acknowledging the sender.', obj.waitForMessageSignature, elapsedTime*1000);
                end 
            end
        elseif (~strcmp(expectedMessageLabel, obj.TRANSMITTED_MESSAGE_MATCHES_EXPECTED))
            % Send back message that the expected message does not match the received one
            if (~strcmp(obj.verbosity,'min'))  && (~strcmp(obj.verbosity,'none'))
                fprintf('%s: Received: ''%s'' <strong>instead of</strong> ''%s''.\n', obj.waitForMessageSignature, response.msgLabel, expectedMessageLabel);
            end
            obj.sendMessage(sprintf('Received (''%s'') message does not match expected (''%s'')', response.msgLabel, expectedMessageLabel), 'nan', 'doNotreplyToThisMessage', true);
        end
    end
    
    function rawMessage = receiveAndUpdateCounter(obj)
        if (obj.useNativeUDP)
            rawMessage = fread(obj.udpClient);
        else
            rawMessage = matlabUDP('receive');
        end
        obj.receivedMessagesCount = obj.receivedMessagesCount + 1;
    end
end


function waitForNewDataArrival()
    while (~matlabUDP('check'))
    end
end

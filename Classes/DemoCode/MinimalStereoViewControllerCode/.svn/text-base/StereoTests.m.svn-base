function StereoTests

    % This setups up some OpenGL constants in the Matlab environment.
    % Essentially, anything in C OpenGL that starts with GL_ becomes GL.., e.g.
    % GL_RECT becomes GL.RECT.  All GL_ are stored globally in the GL struct.
    global GL;
    
    % Initialize the OpenGL for Matlab wrapper 'mogl'.
    % Call this function at the beginning of your experiment script,
    % if you intend to use low-level OpenGL drawing commands.
    % Here, we need it to draw the 3D CrossHairs cursor (using GLW_DrawCrossHairsCursor).
    InitializeMatlabOpenGL;
    
    [displaysAttached, computerStruct] = mglDescribeDisplays;
    if (length(displaysAttached) == 1)
        disp('Must have at least 2 displays attached');
        return;
    end
    
    % Specify screenIDs
    screenIDs = struct;
    screenIDs.left  = 3;
    screenIDs.right = 2;
    if (length(mglDescribeDisplays) == 2)
        screenIDs.left  = 2;
        screenIDs.right = 1;
    end
    
    d = input('Use pre-rendered StereoPair images (1), or openGL objects (2): ');
    if (d == 1)
        % Use radiance warp calibration
        warpFiles = struct;
        warpFiles.left  = 'StereoWarp-Radiance-left';
        warpFiles.right = 'StereoWarp-Radiance-right';
        
        currentStimulusSet = input('Which stimulus set [1 or 2] : ');
        if (currentStimulusSet == 1)
        else
            currentStimulusSet = 2;
        end
        % Stereo image pairs
        currentDir = pwd;
        imageDir   = fullfile(currentDir, 'StereoPairsRepository');
        if (currentStimulusSet == 1)
            imageNames.left  = fullfile(imageDir, 'CubeLeft.tiff');
            imageNames.right = fullfile(imageDir, 'CubeRight.tiff');
        else
            imageNames.left  = fullfile(imageDir, 'Stimulus-Left2.tiff');
            imageNames.right = fullfile(imageDir, 'Stimulus-Right2.tiff');
        end
        %imageNames.left  = fullfile(imageDir, 'Left-Mitsuba.tiff');
        %imageNames.right = fullfile(imageDir, 'Right-Mitsuba.tiff');
        %imageNames.left  = fullfile(imageDir, 'CubeLeft.tiff');
        %imageNames.right = fullfile(imageDir, 'CubeRight.tiff');
        a = imfinfo(imageNames.left);
        widthToHeightRatio = a.Width / a.Height;
        stereoPair = struct;
        stereoPair.imageNames    = imageNames;
        stereoPair.imagePosition = [0 0];
        stereoPair.imageSize     = round(30*[widthToHeightRatio 1]);
        
        targets = struct;
        targets.leftScreen = struct;
        targets.rightScreen = struct;
        
        set = 1;
        targets.rightScreen.XcoordsPxls(set,:) = [723 782 536 500];
        targets.rightScreen.YcoordsPxls(set,:) = [173 285 226 118];
        targets.rightScreen.maximumAcceptableDistancePxls(set) = 20;
        
        set = 2;
        targets.rightScreen.XcoordsPxls(set,:) = [768 678 441 517];
        targets.rightScreen.YcoordsPxls(set,:) = [428 630 596 379];
        targets.rightScreen.maximumAcceptableDistancePxls(set) = 30;
        
        % Map image coordinates to screen coordinates
        % Flip the y-coordinate. On the image, the smallest ycoord is at the top
        % On the screen the smallest ycoord is at the bottom. 
        targets.rightScreen.YcoordsPxls =(a.Height-targets.rightScreen.YcoordsPxls);
        
        % Translate to origin
        targets.rightScreen.YcoordsPxls = targets.rightScreen.YcoordsPxls - a.Height/2;
        targets.rightScreen.XcoordsPxls = targets.rightScreen.XcoordsPxls - a.Width/2;
        
        % Scale to centimeters
        pxlsToCm = stereoPair.imageSize(1) / a.Width;
        targets.rightScreen.XcoordsCm = targets.rightScreen.XcoordsPxls * pxlsToCm;
        targets.rightScreen.YcoordsCm = targets.rightScreen.YcoordsPxls * pxlsToCm;
        
        % Scale maximum acceptable distance to centimeters
        targets.rightScreen.maximumAcceptableDistanceCm = targets.rightScreen.maximumAcceptableDistancePxls * pxlsToCm;
    else
        % Use no-radiance warp calibration
        warpFiles = struct;
        warpFiles.left  = 'StereoWarp-NoRadiance-left';
        warpFiles.right = 'StereoWarp-NoRadiance-right';
    end
    
    
    % 3D cursor (cross-hairs)
    cursorDepthPosition = 0.01;
    crossHairs = struct;
    crossHairs.center = [0 0 cursorDepthPosition];
    crossHairs.diameter = 1.4;
    crossHairs.diskDiameter = 0.6;
    crossHairs.lineWidth = 2.0;
    blackColor(1,:)  = [0.1 0.1 0.1];
    blackColor(2,:)  = blackColor(1,:);
    greenColor(1,:)  = [0.0 1.0 0.0];
    greenColor(2,:)  = greenColor(1,:);    
    
    screenDims = [51.7988 32.3618];
    
    % Stereo params
    stereoParams = struct;
    observerToVergencePlaneDistanceInCm  = 76.4;  % needed to compute asymetric OpenGL frustum
    stereoParams.interOcularDistanceInCm = 6.0;   % needed to compute asymetric OpenGL frustum
    stereoParams.sceneDimensionsInCm     = [screenDims(1) screenDims(2) observerToVergencePlaneDistanceInCm];
   
    % The GLWindow
    stereoGLWindow = [];
    
    try
        
        
        % Construct our stereo GLWindow
        stereoGLWindow = GLWindow(  'DisplayType',          'Stereo', ...
                                    'WindowID',             screenIDs, ...
                                    'WarpFile',             warpFiles, ...
                                    'InterocularDistance',  stereoParams.interOcularDistanceInCm, ...  
                                    'SceneDimensions',      stereoParams.sceneDimensionsInCm);         
                

        stereoGLWindow.open;
        
        if (exist('stereoPair'))
            stereoGLWindow.addImageFromFile(stereoPair.imagePosition, stereoPair.imageSize, stereoPair.imageNames, 'Name', 'StereoScene');
        end
        
        % Add the target boxes (for debugging)
        
        xpos = targets.rightScreen.XcoordsCm(currentStimulusSet,:);
        ypos = targets.rightScreen.YcoordsCm(currentStimulusSet,:);
        targetBoxColor.left = [1 0 0];
        targetBoxColor.right = targetBoxColor.left;
        for targetIndex = 1:length(ypos)
            pos.left  = [0 0 -10000];  % invisible
            pos.right = [xpos(targetIndex) ypos(targetIndex) 0.001];
            size = targets.rightScreen.maximumAcceptableDistanceCm(set);
            objectName = sprintf('TargetBox%d', targetIndex);
            stereoGLWindow.addRectangle(pos, size*[1 1], targetBoxColor, 'Name', objectName);
            stereoGLWindow.disableObject(objectName);
        end
        
        % Add the 3D cursor
%        stereoGLWindow.addCursor3D(crossHairs.diameter, crossHairs.diskDiameter, crossHairs.lineWidth, blackColor, 'Name', 'CrossHairsCursor');
%        stereoGLWindow.Cursor3Dposition = crossHairs.center;
        
        
        % Add the left/right red square
        pos.left = [0 0 0];
        pos.right = [0 0 0 ];
        VergencePlaneCursorColor = struct;
        VergencePlaneCursorColor.left = [0 1 0];
        VergencePlaneCursorColor.right = [0 1 0];
        stereoGLWindow.addRectangle(pos, [0.5 0.5], VergencePlaneCursorColor, 'Name', 'VergencePlaneCursorLocation');
        stereoGLWindow.disableObject('VergencePlaneCursorLocation');
        stereoGLWindow.draw;
        
        
        if (mglIsCursorVisible)
            mglDisplayCursor(0);
        end

        Speak('Right mouse button quits', 'alex');
        % Set the mouse position in pixels coords (relative to left screen)
        xMousePixels = round(displaysAttached(screenIDs.left).screenSizePixel(1) / 2) * (1 + crossHairs.center(1) / (stereoParams.sceneDimensionsInCm(1)/2));
        yMousePixels = round(displaysAttached(screenIDs.left).screenSizePixel(2) / 2) * (1 + crossHairs.center(2) / (stereoParams.sceneDimensionsInCm(2)/2));
        mglSetMousePosition(xMousePixels, yMousePixels, screenIDs.left);
        
        % Construct a Mouse Object
        mouseInput = Mouse(displaysAttached);
        
        
        keepMoving = true;
        
        
                    
        while (keepMoving)
            
            [mouseXposPixels, mouseYposPixels, mouseButtonState] = mouseInput.getMouseStatePx;
            
            if (mouseButtonState ~= 2)  % no Button pressed
                stereoGLWindow.disableObject('VergencePlaneCursorLocation');
                m = mouseInput.px2cm(screenIDs.left, stereoParams.sceneDimensionsInCm);
                if (~isempty(m))
                    crossHairs.center = [m.x m.y crossHairs.center(3)];
                    stereoGLWindow.Cursor3Dposition = crossHairs.center;
                end
                
                giveTryAgainFeedback = false;
                
                if (mouseButtonState == 1)
                    % Verify reported position on left and right displays
                    a = stereoGLWindow.Cursor3Dposition;
                    fprintf('Cursor 3D XYZ position: %2.2f %2.2f %2.2f\n', a.virtualXYZposition(1), a.virtualXYZposition(2), a.virtualXYZposition(3));
                    fprintf('Cursor 2D position on left display: %2.2f %2.2f\n',  a.displayXYZposition(1,1), a.displayXYZposition(1,2));
                    fprintf('Cursor 2D position on right display: %2.2f %2.2f\n', a.displayXYZposition(2,1), a.displayXYZposition(2,2));
        
                    
                    position.left  = a.displayXYZposition(1,:);
                    position.right = a.displayXYZposition(2,:);
       
                    for targetIndex = 1:length(ypos)
                        xo = xpos(targetIndex);
                        yo = ypos(targetIndex);
                        mx = a.displayXYZposition(2,1);
                        my = a.displayXYZposition(2,2);
                        dx = xo - mx;
                        dy = yo - my;
                        dist(targetIndex) = sqrt(dx^2+dy^2);
                    end
                    
                    [minDist, selectedTargetIndex] = min(dist);
                    if (minDist <= targets.rightScreen.maximumAcceptableDistanceCm)
                        objectName = sprintf('TargetBox%d', selectedTargetIndex);
                        stereoGLWindow.enableObject(objectName);
                    else
                        giveTryAgainFeedback = true;
                    end

                    stereoGLWindow.setObjectProperty('CrossHairsCursor', 'Color', greenColor);
                    %stereoGLWindow.addRectangle(position , [0.5 0.5], VergencePlaneCursorColor, 'Name', 'VergencePlaneCursorLocation');
                    %stereoGLWindow.enableObject('VergencePlaneCursorLocation');
                    
                else
                   for targetIndex = 1:length(ypos)
                        objectName = sprintf('TargetBox%d', targetIndex);
                        stereoGLWindow.disableObject(objectName);
                   end
                   stereoGLWindow.setObjectProperty('CrossHairsCursor', 'Color', blackColor);
                end
                
                stereoGLWindow.draw;
                
                if (giveTryAgainFeedback)
                    Speak('Try again !', 'alex');
                end
            else
                
                keepMoving = false;
                
            end
           
        end
        

        
        mglDisplayCursor(1);
        mglSetMousePosition(512, 512, 1);
        stereoGLWindow.close;
        
    catch e
        ListenChar(0);
        mglDisplayCursor(1);
        mglSetMousePosition(512, 512, 1);
        if (~isempty(stereoGLWindow))
           stereoGLWindow.close; 
        end
        rethrow(e); 
    end
end

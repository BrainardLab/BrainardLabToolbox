function MinimalStereoCode
% MinimalStereoCode - Minimum code to display a stereo stimulus
%
% Syntax:
% DisparityInducedSizeConstancyDemo
%
% 2/12/2012    npc     Wrote it.
% 6/11/2014    npc     Started updates for the SONY HDR stereo display.
%
    % Get information about the system we are running on
    [displaysAttached, computerStruct] = mglDescribeDisplays;
    computerStruct
    
    % If we are not running this demo in the Stereo Rig (4 screens attached)
    % choose the first two screens as our right and left screens
    if (length(displaysAttached) == 2)
       % main screen is for right eye, secondary screen for left eye
       windowIDs.left  = 1;
       windowIDs.right = 2;
       checkForScreenSize = false;
    elseif (length(displaysAttached) == 3)
       windowIDs.right = 2;
       windowIDs.left  = 3;
       checkForScreenSize = true;
    elseif (length(displaysAttached) == 4)
       windowIDs.right = 3;
       windowIDs.left  = 4;
       checkForScreenSize = true;
    else
       return;
    end

    % Specify calibration files for left and right screens
    leftScreenCalFile   = 'StereoLCDLeft';
    rightScreenCalFile  = 'StereoLCDRight';
    calFnames           = {leftScreenCalFile, rightScreenCalFile};
    
    % Import RGB calibration data
    [leftCal, rightCal] = importStereoRGBCalibrationFiles(calFnames, leftScreenCalFile, rightScreenCalFile, displaysAttached, checkForScreenSize);
    

    % Specify stereo warp files for left and right screens
    warpFile       = struct;
    warpFile.left  = 'StereoWarp-Radiance-left';
    warpFile.right = 'StereoWarp-Radiance-right';
    warpCalFnames  = {warpFile.left, warpFile.right};
    inspectWarpFiles(warpCalFnames);
    

   % Specify parameters relevant to 3D rendering
   % (1) istance of the backplane from viewer in cm
   distanceOfBackPlaneFromViewerInCm = 76.4;
   % (2) Interocular distance, in cm
   interOcularDistanceInCm = 6.3;

   % Specify our scence dimensions (in centimeters) as follows:
   screenWidthInCm  = 54.18667;
   screenHeightInCm = 30.48000;
   sceneDimensions  = [screenWidthInCm screenHeightInCm distanceOfBackPlaneFromViewerInCm];

   % Specify a black background for both left and right screens
   backgroundColor.left  = [0.0 0.0 0.0];
   backgroundColor.right = backgroundColor.left;

   % is sanityCheck is true we present test screens to make sure
   % OSX has not flipped left and right screens.
   sanityCheck = true;

   try
        ListenChar(2);
        mglGetKeyEvent;

        % Generate a full screen GLWindow
        win = GLWindow( 'FullScreen', true, ...
                        'SceneDimensions', sceneDimensions, ...
                        'DisplayType', 'Stereo', ...
                        'BackgroundColor', backgroundColor, ...
                        'WarpFile', warpFile, ...
                        'WindowID', windowIDs);

        % set the Interocular distance property
        win.InterocularDistance = interOcularDistanceInCm;

        % Open the GLWindow
        win.open;
        
       
        if (sanityCheck)
            performSanityCheck(win);
        end
        
           

       % make the background gray
       backgroundColor.left  = 0.2*[1 1 1];
       backgroundColor.right = backgroundColor.left;
       win.BackgroundColor  = backgroundColor;


       % add a noisy teture
       noiseTexture = struct;
       noiseTexture.left  = rand(512, 512, 3);
       noiseTexture.right = noiseTexture.left;
       dims  = 28*[1024.0/768.0 1.0];
       
       % the following fails with message: 
       % ??? Error using ==> GLWindow.addImage at 29
       % Argument 'Center' failed validation @(x)(isvector(x)&&length(x)==2)||(isnumeric(x)&&numel(x)==4).
       %depthOfNoiseTexture = -5;
       %win.addImage([0 0 depthOfNoiseTexture], noiseTexture.dims, noiseTexture, 'Name', 'randomPatch');
       % win.addImage([0 0], dims, noiseTexture, 'Name', 'randomPatch');
       currentDir = pwd;
       leftImageFileName   = sprintf('%s/StereoPairsRepository/CubeLeft.tiff', currentDir);
       rightImageFileName  = sprintf('%s/StereoPairsRepository/CubeRight.tiff', currentDir);
       stereoImageFileNames = {leftImageFileName, rightImageFileName}; 
       win.addImageFromFile([0 0], dims, stereoImageFileNames, 'Name', 'testImage');
        
       % Specify target patch properties
       target = struct;
       target.color.left   = [0.97 0.97 0.97];
       target.color.right  = [0.97 0.97 0.97];
       target.dims         = [3.5 3.5];
       
       % Coords in 3D space
       target.centerPos3D          = [0 0 0.1];

       % add the target patch
       win.addRectangle(target.centerPos3D, target.dims, target.color, 'Name', 'target');

       
       % start the animation
       keepLooping = true;

        
       while(keepLooping)
          
           % Render the scene
               win.draw;
               
                
               key = mglGetKeyEvent;
               if (~isempty(key))
                   
                   %Speak(key.charCode,'Victoria');
                   
                   deltaXYDepth = [0 0 0];
                   
                   switch (key.charCode)
                       case 'i'
                           % move object far
                           deltaXYDepth = [0 0 0.25];
                       case 'k'
                           % move object near
                           deltaXYDepth = [0 0 -0.25]; 
                       case 'w'
                           % move object up
                           deltaXYDepth = [0 0.25 0]; 
                       case 's'
                           % move object down
                           deltaXYDepth = [0 -0.25 0]; 
                       case 'a'
                           % move object left
                           deltaXYDepth = [-0.25 0 0]; 
                       case 'd'
                           % move object right
                           deltaXYDepth = [0.25 0 0]; 
                       case 'q'
                           % break out of the FOR and the WHILE loops
                           keepLooping = false;
                   end  % switch
                   
                  % target.centerPos3D = target.centerPos3D + deltaXYDepth;
                  % win.setObjectProperty('target', 'Center', repmat(target.centerPos3D, [2 1]));
                           
                   
               end  % ~isempty(key)
               
       end  % keepLooping
       
       ListenChar(0);
       win.close;

   catch e
       ListenChar(0);
       if ~isempty(win)
           win.close;
       end
       rethrow(e);
   end
end


